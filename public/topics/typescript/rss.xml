<?xml version="1.0" encoding="UTF-8"?>
<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0">
    <channel>
        <title>ChrisÂ Krycho</title>
        <link>v4.chriskrycho.com</link>
        <description>Seeking truth &amp; pursuing excellence.</description>
        <generator>Zola</generator>
        <language>en</language>
        <atom:link href="v4.chriskrycho.com/topics/typescript/rss.xml" rel="self" type="application/rss+xml"/>
        <lastBuildDate>Sat, 27 Oct 2018 17:00:00 -0700</lastBuildDate>
        
            <item>
                <title>True Myth 2.2</title>
                <pubDate>Sat, 27 Oct 2018 17:00:00 -0700</pubDate>
                <link>v4.chriskrycho.com/true-myth-22/</link>
                <guid>v4.chriskrycho.com/true-myth-22/</guid>
                <description>&lt;p&gt;I just released v2.2&lt;sup class=&quot;footnote-reference&quot;&gt;&lt;a href=&quot;#1&quot;&gt;1&lt;&#x2F;a&gt;&lt;&#x2F;sup&gt; of True Myth, with two new pairs of helpers to deal with &lt;a href=&quot;v4.chriskrycho.com&#x2F;true-myth-22&#x2F;#safe-java-script-object-property-lookup&quot;&gt;safe JavaScript object property lookup with &lt;code&gt;Maybe&lt;&#x2F;code&gt;s&lt;&#x2F;a&gt; and &lt;a href=&quot;v4.chriskrycho.com&#x2F;true-myth-22&#x2F;#handling-exception-throwing-functions&quot;&gt;handling exception-throwing code with &lt;code&gt;Result&lt;&#x2F;code&gt;s&lt;&#x2F;a&gt;.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;safe-javascript-object-property-lookup&quot;&gt;Safe JavaScript object property lookup&lt;&#x2F;h2&gt;
&lt;p&gt;We often deal with &lt;em&gt;optional properties&lt;&#x2F;em&gt; on JavaScript objects, and by default JavaScript just gives us &lt;code&gt;undefined&lt;&#x2F;code&gt; if a property doesn&#x27;t exist on an object and we look it up:&lt;&#x2F;p&gt;
&lt;pre&gt;&lt;code&gt;type Person = {
  name?: string;
};

let me: Person = { name: &#x27;Chris&#x27; };
console.log(me.name); &#x2F;&#x2F; Chris

let anonymous: Person = {};
console.log(anonymous.name); &#x2F;&#x2F; undefined
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;We can already work around that with &lt;code&gt;Maybe.of&lt;&#x2F;code&gt;, of course:&lt;&#x2F;p&gt;
&lt;pre&gt;&lt;code&gt;function printName(p: Person) {
  let name = Maybe.of(p.name);
  console.log(name.unwrapOr(&#x27;&amp;lt;anonymous&amp;gt;&#x27;));
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;But this is a &lt;em&gt;really&lt;&#x2F;em&gt; common pattern! &lt;code&gt;Maybe.property&lt;&#x2F;code&gt; is a convenience method for dealing with this:&lt;&#x2F;p&gt;
&lt;pre&gt;&lt;code&gt;function printName(p: Person) {
  let name = Maybe.property(&#x27;name&#x27;, p);
  console.log(name.unwrapOr(&#x27;&amp;lt;anonymous&amp;gt;&#x27;));
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;At first blush, this might be a head-scratcher: after all, it&#x27;s actually slightly &lt;em&gt;longer&lt;&#x2F;em&gt; than doing it with &lt;code&gt;Maybe.of&lt;&#x2F;code&gt;. However, it ends up showing its convenience when you&#x27;re using the curried form in a functional pipeline. For example, if we had a &lt;em&gt;list&lt;&#x2F;em&gt; of people, and wanted to get a list of just the people&#x27;s names (ignoring anonymous people), we might do this:&lt;&#x2F;p&gt;
&lt;pre&gt;&lt;code&gt;function justNames(people: Person[]): string[] {
  return people
    .map(Maybe.property(&#x27;name&#x27;))
    .filter(Maybe.isJust)
    .map(Just.unwrap);
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Another common scenario is dealing with the same kind of lookup, but in the context of a &lt;code&gt;Maybe&lt;&#x2F;code&gt; of an object. Prior to 2.2.0, we could do this with a combination of &lt;code&gt;Maybe.of&lt;&#x2F;code&gt; and &lt;code&gt;andThen&lt;&#x2F;code&gt;:&lt;&#x2F;p&gt;
&lt;pre&gt;&lt;code&gt;function getName(maybePerson: Maybe&amp;lt;Person&amp;gt;): string {
  return maybePerson.andThen(p =&amp;gt; Maybe.of(p.name));
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;This is harder to compose than we might like, and we &lt;em&gt;can&#x27;t&lt;&#x2F;em&gt; really write it in a &amp;quot;point free&amp;quot; style, even if that&#x27;s more convenient. We also end up repeating the &lt;code&gt;andThen&lt;&#x2F;code&gt; invocation every time we go down a layer if we have a more deeply nested object than this. Accordingly, 2.2.0 also adds another convenience method for dealing with deeply nested lookups on objects in a type-safe way: &lt;code&gt;Maybe.get&lt;&#x2F;code&gt; (and the corresponding instance methods).&lt;&#x2F;p&gt;
&lt;pre&gt;&lt;code&gt;&#x2F;&#x2F; Function version:
function getNameFn(maybePerson: Maybe&amp;lt;Person&amp;gt;): string {
  return Maybe.get(&#x27;name&#x27;, maybePerson);
}

&#x2F;&#x2F; Method version
function getNameM(maybePerson: Maybe&amp;lt;Person&amp;gt;): string {
  return maybePerson.get(&#x27;name&#x27;);
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Again, since the function version is curried, we can use this to create other little helper functions along the way:&lt;&#x2F;p&gt;
&lt;pre&gt;&lt;code&gt;const getName = Maybe.get(&#x27;name&#x27;);

function getAllNames(people: Maybe&amp;lt;Person&amp;gt;[]): string[] {
  return people
    .map(getName)
    .filter(Maybe.isJust)
    .map(Just.unwrap);
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;And if our object is a deeper type:&lt;&#x2F;p&gt;
&lt;pre&gt;&lt;code&gt;type ComplicatedPerson = {
  name?: {
    first?: string;
    last?: string;
  };
};

let none: Maybe&amp;lt;ComplicatedPerson&amp;gt; = Maybe.nothing();
console.log(none.get(&#x27;name&#x27;).toString());
&#x2F;&#x2F; Nothing
console.log(none.get(&#x27;name&#x27;).get(&#x27;first&#x27;).toString());
&#x2F;&#x2F; Nothing

let nameless: Maybe&amp;lt;ComplicatedPerson&amp;gt; = Maybe.just({});
console.log(nameless.get(&#x27;name&#x27;).toString());
&#x2F;&#x2F; Just([object Object]);
console.log(nameless.get(&#x27;name&#x27;).get(&#x27;first&#x27;).toString());
&#x2F;&#x2F; Nothing

let firstOnly: Maybe&amp;lt;ComplicatedPerson&amp;gt; = Maybe.just({
  name: {
    first: &#x27;Chris&#x27;,
  },
});
console.log(firstOnly.get(&#x27;name&#x27;).toString());
&#x2F;&#x2F; Just([object Object]);
console.log(firstOnly.get(&#x27;name&#x27;).get(&#x27;first&#x27;).toString());
&#x2F;&#x2F; Just(Chris);
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Note that in these cases, since the type we&#x27;re dealing with is some kind of object with specific keys, if you try to pass in a key which doesn&#x27;t existing on the relevant object type, you&#x27;ll get a type error. (Or, if you&#x27;re using the curried version, if you try to pass an object which doesn&#x27;t have that key, you&#x27;ll get a type error.) However, we also often use JavaScript objects as &lt;em&gt;dictionaries&lt;&#x2F;em&gt;, mapping from a key to a value (most often, but not always, a &lt;em&gt;string&lt;&#x2F;em&gt; key to a specific value type). &lt;code&gt;Maybe.property&lt;&#x2F;code&gt; and &lt;code&gt;Maybe.get&lt;&#x2F;code&gt; both work with dictionary types as well.&lt;&#x2F;p&gt;
&lt;pre&gt;&lt;code&gt;type Dict&amp;lt;T&amp;gt; = { [key: string]: T };

let ages: Dict&amp;lt;number&amp;gt; = {
  &#x27;chris&#x27;: 31,
};

console.log(Maybe.property(&#x27;chris&#x27;, ages)); &#x2F;&#x2F; Just(31)
console.log(Maybe.property(&#x27;joe&#x27;, ages)); &#x2F;&#x2F; Nothing

let maybeAges: Maybe&amp;lt;Dict&amp;lt;number&amp;gt;&amp;gt; = Maybe.of(ages);
console.log(ages.get(&#x27;chris&#x27;)); &#x2F;&#x2F; Just(31)
console.log(ages.get(&#x27;joe&#x27;)); &#x2F;&#x2F; Nothing
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Hopefully you&#x27;ll find these helpful! I ran into the motivating concerns for them pretty regularly in the codebase I work with each day, so I&#x27;m looking forward to integrating them into that app!&lt;&#x2F;p&gt;
&lt;h2 id=&quot;handling-exception-throwing-functions&quot;&gt;Handling exception-throwing functions&lt;&#x2F;h2&gt;
&lt;p&gt;The other big additions are the &lt;code&gt;Result.tryOr&lt;&#x2F;code&gt; and &lt;code&gt;Result.tryOrElse&lt;&#x2F;code&gt; functions. Both of these help us deal with functions which throw exceptions. Since JavaScript doesn&#x27;t have any &lt;em&gt;native&lt;&#x2F;em&gt; construct like &lt;code&gt;Result&lt;&#x2F;code&gt;, idiomatic JavaScript &lt;em&gt;does&lt;&#x2F;em&gt; often throw exceptions. And that can be frustrating you want to have a value type like a &lt;code&gt;Result&lt;&#x2F;code&gt; to deal with instead.&lt;&#x2F;p&gt;
&lt;p&gt;Sometimes, you don&#x27;t care &lt;em&gt;what&lt;&#x2F;em&gt; the exception was; you just want a default value (or a value constructed from the local state of your program, but either way just one value) you can use as the error to keep moving along through your program. In that case, you wrap a function which throws an error in &lt;code&gt;Result.tryOr&lt;&#x2F;code&gt;. Let&#x27;s assume we have a function either returns a number of throws an error, which we&#x27;ll just call &lt;code&gt;badFunction&lt;&#x2F;code&gt; because the details here don&#x27;t really matter.&lt;&#x2F;p&gt;
&lt;pre&gt;&lt;code&gt;const err = &#x27;whoops! something went wrong!&#x27;;
const result = Result.tryOr(err, badFunction());
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;The &lt;code&gt;result&lt;&#x2F;code&gt; value has the type &lt;code&gt;Result&amp;lt;number, string&amp;gt;&lt;&#x2F;code&gt;. If &lt;code&gt;badFunction&lt;&#x2F;code&gt; through an error, we have an &lt;code&gt;Err&lt;&#x2F;code&gt; with the value &lt;code&gt;&#x27;whoops! something went wrong!&#x27;&lt;&#x2F;code&gt; in it. If it &lt;em&gt;didn&#x27;t&lt;&#x2F;em&gt; throw an error, we have an &lt;code&gt;Ok&lt;&#x2F;code&gt; with the number returned from &lt;code&gt;badFunction&lt;&#x2F;code&gt; in it. Handy!&lt;&#x2F;p&gt;
&lt;p&gt;Of course, we often want to &lt;em&gt;do something&lt;&#x2F;em&gt; with the exception that gets thrown. For example, we might want to log an error to a bug-tracking service, or display a nice message to the user, or any number of other things. In that case, we can use the &lt;code&gt;Result.tryOrElse&lt;&#x2F;code&gt; function. Let&#x27;s imagine we have a function &lt;code&gt;throwsHelpfulErrors&lt;&#x2F;code&gt; which returns a &lt;code&gt;number&lt;&#x2F;code&gt; or does just what it says on the tin: it throws a bunch of different kinds of errors, which are helpfully distinct and carry around useful information with them. Note that the type of the error-handling callback we pass in is &lt;code&gt;(error: unknown) =&amp;gt; E&lt;&#x2F;code&gt;, because JS functions can throw &lt;em&gt;anything&lt;&#x2F;em&gt; as their error.&lt;&#x2F;p&gt;
&lt;pre&gt;&lt;code&gt;const handleErr = (e: unknown): string =&amp;gt; {
  if (e instanceof Error) {
    return e.message;
  } else if (typeof e === &#x27;string&#x27;) {
    return e;
  } else if (typeof e === &#x27;number&#x27;) {
    return &#96;Status code: ${e}&#96;;
  } else {
    return &#x27;Unknown error&#x27;;
  }
}

const result = Result.tryOrElse(handleErr, throwsHelpfulErrors);
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Here, &lt;code&gt;result&lt;&#x2F;code&gt; is once again a &lt;code&gt;Result&amp;lt;number, string&amp;gt;&lt;&#x2F;code&gt;, but the error side has whatever explanatory information the exception provided to us, plus some massaging we did ourselves. This is particularly handy for converting exceptions to &lt;code&gt;Result&lt;&#x2F;code&gt;s when you have a library which uses exceptions extensively, but in a carefully structured way. (You could, in fact, just use an identity function to return whatever error the library throwsâas long as you write your types carefully and accurately as a union of those error types for the &lt;code&gt;E&lt;&#x2F;code&gt; type parameter! However, doing that would require you to explicitly opt into the use of &lt;code&gt;any&lt;&#x2F;code&gt; to write it as a simple identity function, so I&#x27;m not sure I&#x27;d &lt;em&gt;recommend&lt;&#x2F;em&gt; it. If you go down that path, do it with care.)&lt;&#x2F;p&gt;
&lt;hr &#x2F;&gt;
&lt;p&gt;And that&#x27;s it for True Myth 2.2! Enjoy, and of course please &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;true-myth&#x2F;true-myth&#x2F;issues&quot;&gt;open an issue&lt;&#x2F;a&gt; if you run into any bugs!&lt;&#x2F;p&gt;
&lt;p&gt;Thanks to &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;bmakuh&quot;&gt;Ben Makuh&lt;&#x2F;a&gt; for implementing &lt;code&gt;Result.tryOr&lt;&#x2F;code&gt; and &lt;code&gt;Result.tryOrElse&lt;&#x2F;code&gt;. Thanks to Ben and also &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;tansongyang&quot;&gt;Frank Tan&lt;&#x2F;a&gt; for helpful input on the &lt;code&gt;Maybe.get&lt;&#x2F;code&gt; and &lt;code&gt;Maybe.property&lt;&#x2F;code&gt; &lt;abbr&gt;API&lt;&#x2F;abbr&gt; design!&lt;&#x2F;p&gt;
&lt;hr &#x2F;&gt;
&lt;div class=&quot;footnote-definition&quot; id=&quot;1&quot;&gt;&lt;sup class=&quot;footnote-definition-label&quot;&gt;1&lt;&#x2F;sup&gt;
&lt;p&gt;I published both &lt;code&gt;2.2.0&lt;&#x2F;code&gt; and &lt;code&gt;2.2.1&lt;&#x2F;code&gt;, because once again I missed something along the way. This time it was making sure all the new functions were optionally curried to support partial application.&lt;&#x2F;p&gt;
&lt;&#x2F;div&gt;
</description>
            </item>
        
            <item>
                <title>Higher-Order Components in Ember.js</title>
                <pubDate>Sat, 26 May 2018 14:00:00 -0600</pubDate>
                <link>v4.chriskrycho.com/ember-hoc/</link>
                <guid>v4.chriskrycho.com/ember-hoc/</guid>
                <description>&lt;p&gt;One of the most powerful patterns in programming is the idea of &lt;em&gt;higher-order functions&lt;&#x2F;em&gt;: functions which can take other functions as arguments or return them as their return values. If youâve spent much time at all working in JavaScript, youâve certainly encountered theseâwhether youâre using &lt;code&gt;Array.map&lt;&#x2F;code&gt; to transform the values in an array, or passing a function as an argument to an event handler.&lt;&#x2F;p&gt;
&lt;p&gt;The same pattern is incredibly useful in building components, and most modern front-end frameworks support itâincluding Ember.js! (In React, the pattern as a whole is often known as the &lt;code&gt;renderProps&lt;&#x2F;code&gt; pattern, for the way you most often accomplish it. It&#x27;s all the same idea, though!)&lt;&#x2F;p&gt;
&lt;p&gt;In this little post, Iâll show you how to build a small âhigher-order componentâ in Ember.js, hopefully demystifying that term a little bit a long the way. (If you just want to see how the pieces fit together, you can see the finished app &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;chriskrycho&#x2F;ember-hoc-example&quot;&gt;in this repo&lt;&#x2F;a&gt;.)&lt;&#x2F;p&gt;
&lt;aside&gt;
&lt;p&gt;Iâm going to be using classes and decorators throughout. Both are very much ready-to-go in Ember, and I commend them to you! Iâm also going to be using some of the new &lt;a href=&quot;https:&#x2F;&#x2F;emberjs.com&#x2F;blog&#x2F;2018&#x2F;04&#x2F;13&#x2F;ember-3-1-released.html#toc_introducing-optional-features-3-of-4&quot;&gt;optional features&lt;&#x2F;a&gt; available in Ember 3.1+ to use template-only components!&lt;&#x2F;p&gt;
&lt;p&gt;Note that one of the most important consequences of this is that arguments have to be referenced as &lt;code&gt;@theArgumentName&lt;&#x2F;code&gt; rather than just &lt;code&gt;theArgumentName&lt;&#x2F;code&gt; in templates. The reason is precisely that there is no backing JavaScript component. In old-school Ember.js components, &lt;code&gt;{{theArgumentName}}&lt;&#x2F;code&gt; is implicitly turned into &lt;code&gt;{{this.argumentName}}&lt;&#x2F;code&gt;, which does a lookup on the backing component. In Glimmer-style componentsâof which these are the first partâarguments live on a designated &lt;code&gt;args&lt;&#x2F;code&gt; property and are accessible in templates via &lt;code&gt;@theArgumentName&lt;&#x2F;code&gt; instead.&lt;&#x2F;p&gt;
&lt;&#x2F;aside&gt;
&lt;h2 id=&quot;higher-order-components-what-are-they&quot;&gt;Higher-Order Components, What Are They&lt;&#x2F;h2&gt;
&lt;p&gt;Just like with a âhigher-order function,â all we mean when we talk about a âhigher-order componentâ is a component which takes other components as arguments, returns other components itself (in Emberâs case via &lt;code&gt;yield&lt;&#x2F;code&gt; in a template), or both.&lt;&#x2F;p&gt;
&lt;p&gt;The thing weâre actually going to build here is a âmodalâ which accepts an optional button as an arguments, and which yields out a component for dividing the modal into sections visually so you can pass your own content in and have it look just right. This is closely based on a component my colleagues and I at Olo built recently, just with some of our specific details stripped away to get at the actually important bits. Here&#x27;s what it looks like in practice:&lt;&#x2F;p&gt;
&lt;figure&gt;
&lt;img src=&quot;https:&#x2F;&#x2F;f001.backblazeb2.com&#x2F;file&#x2F;chriskrycho-com&#x2F;images&#x2F;hoc-rendered.png&quot; alt=&quot;modal component with sections&quot;&gt;
&lt;figcaption&gt;a modal with sectioned text and a close button&lt;&#x2F;figcaption&gt;
&lt;&#x2F;figure&gt;
&lt;p&gt;The goal for the button arguments is to let the modal be able to render the button the caller passes in, while not being concerned with the &lt;em&gt;functionality&lt;&#x2F;em&gt; of the button. Otherwise, weâd have to tie the âAPIâ of the modal to the details of button behavior, bind more actions into it, etc.&lt;&#x2F;p&gt;
&lt;p&gt;The goal for the yielded sectioning component is for whatever is rendering the modal itself to be able to pass content in and get it chunked up however the modal decides is appropriateâthe modal can display its own styles, etc.âwithout having to worry about the details of applying classes or sectioning up the content itself.&lt;&#x2F;p&gt;
&lt;p&gt;In short, we want to &lt;em&gt;separate our concerns&lt;&#x2F;em&gt;: the modal knows how to lay out its contents and where to put buttons, but it doesnât want to have to know &lt;em&gt;anything&lt;&#x2F;em&gt; about what the buttons do. The most complicated interaction in the world could be going on, and the modal wonât have to care. Likewise, things &lt;em&gt;using&lt;&#x2F;em&gt; the modal can pass content and buttons into it, and let the modal manage its own layout and so on without having to be concerned with the details of that. So what does that look like in practice?&lt;&#x2F;p&gt;
&lt;p&gt;The approach I use here builds on the &amp;quot;contextual components&amp;quot; pattern in Ember.js. The main new idea is that the &lt;em&gt;context&lt;&#x2F;em&gt; includes components!&lt;&#x2F;p&gt;
&lt;h2 id=&quot;implementing-it&quot;&gt;Implementing It&lt;&#x2F;h2&gt;
&lt;p&gt;We have three components here:&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;a button&lt;&#x2F;li&gt;
&lt;li&gt;a modal&lt;&#x2F;li&gt;
&lt;li&gt;a modal section&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;Since Ember.js still (for now!) requires component names to be at least two words separated by a dash, weâll just call these &lt;code&gt;x-button&lt;&#x2F;code&gt;, &lt;code&gt;x-modal&lt;&#x2F;code&gt;, and &lt;code&gt;x-modal-section&lt;&#x2F;code&gt;.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;x-button&quot;&gt;&lt;code&gt;x-button&lt;&#x2F;code&gt;&lt;&#x2F;h3&gt;
&lt;p&gt;The button component, weâll keep pretty simple: itâs just a button element with a given label and an action bound to it:&lt;&#x2F;p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;button class={{@buttonClass}} type=&#x27;button&#x27; {{action @onClick}}&amp;gt;
  {{@label}}
&amp;lt;&#x2F;button&amp;gt;
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h3 id=&quot;x-modal&quot;&gt;&lt;code&gt;x-modal&lt;&#x2F;code&gt;&lt;&#x2F;h3&gt;
&lt;p&gt;The &lt;code&gt;x-modal&lt;&#x2F;code&gt; has the meat of the implementation.&lt;&#x2F;p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;div class=&#x27;modal-backdrop&#x27;&amp;gt;&amp;lt;&#x2F;div&amp;gt;
&amp;lt;div class=&#x27;modal&#x27;&amp;gt;
  &amp;lt;div class=&#x27;modal-content&#x27;&amp;gt;
    {{yield (hash section=(component &#x27;x-modal-section&#x27;))}}
  &amp;lt;&#x2F;div&amp;gt;

  {{#if @button}}
    {{component @button buttonClass=&#x27;modal-button&#x27;}}
  {{&#x2F;if}}
&amp;lt;&#x2F;div&amp;gt;
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;The two things two notice here are the &lt;code&gt;yield&lt;&#x2F;code&gt; and the &lt;code&gt;component&lt;&#x2F;code&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;The &lt;code&gt;yield&lt;&#x2F;code&gt; statement yields a &lt;a href=&quot;https:&#x2F;&#x2F;www.emberjs.com&#x2F;api&#x2F;ember&#x2F;3.1&#x2F;classes&#x2F;Ember.Templates.helpers&quot;&gt;&lt;code&gt;hash&lt;&#x2F;code&gt;&lt;&#x2F;a&gt; with one property: &lt;code&gt;section&lt;&#x2F;code&gt;. Yielding a hash is a convenient pattern in general. Here, weâre doing it to make the &lt;abbr&gt;API&lt;&#x2F;abbr&gt; nicer for users of this component. It means that if we name the yielded value &lt;code&gt;|modal|&lt;&#x2F;code&gt; when we invoke this, weâll be able to write &lt;code&gt;modal.section&lt;&#x2F;code&gt; to name this particular yielded item. (Youâll see exactly this below.)&lt;&#x2F;p&gt;
&lt;p&gt;We use the &lt;code&gt;component&lt;&#x2F;code&gt; helper twice: once as the value of the &lt;code&gt;section&lt;&#x2F;code&gt; key in the yielded hash, and once for the &lt;code&gt;button&lt;&#x2F;code&gt; below. In both cases, the helper does the same thing: invokes a component! While the most common way to render a component is with its name, inlineâlike &lt;code&gt;{{x-modal}}&lt;&#x2F;code&gt;âyou can always render it with the &lt;code&gt;component&lt;&#x2F;code&gt; helper and the name as a string: &lt;code&gt;{{component &#x27;x-modal&#x27;}}&lt;&#x2F;code&gt;. This lets you render different components dynamically!&lt;&#x2F;p&gt;
&lt;p&gt;Letâs remember our initial analogy: the same way you can pass different functions to a higher-order function like &lt;code&gt;Array.prototype.map&lt;&#x2F;code&gt;, you can pass different components to a higher-order component like our &lt;code&gt;x-modal&lt;&#x2F;code&gt; here. And just like you can &lt;em&gt;return&lt;&#x2F;em&gt; a function from a higher-order function, we can &lt;em&gt;yield&lt;&#x2F;em&gt; a component from a higher-order component. Just like higher-order functions, the function passed in or returned just has to have the right shape.&lt;&#x2F;p&gt;
&lt;p&gt;For example, the argument to &lt;code&gt;Array.prototype.map&lt;&#x2F;code&gt; needs to be a function which performs an operation on a single item in the array (and maybe also the index) and hands back the result of that operation. Similarly, the &lt;code&gt;button&lt;&#x2F;code&gt; argument to our &lt;code&gt;x-modal&lt;&#x2F;code&gt; needs to accept a &lt;code&gt;buttonClass&lt;&#x2F;code&gt; component so that the modal can apply some styling to it. The same thing holds for the component being yielded back out: it has an &lt;abbr&gt;API&lt;&#x2F;abbr&gt; you should use to invoke it, just like any other.&lt;sup class=&quot;footnote-reference&quot;&gt;&lt;a href=&quot;#1&quot;&gt;1&lt;&#x2F;a&gt;&lt;&#x2F;sup&gt;&lt;&#x2F;p&gt;
&lt;p&gt;All of this gets at something really important: you can think of components as just being &lt;em&gt;pure functions&lt;&#x2F;em&gt;: they take some input in the form of arguments, and give you the output of what they &lt;em&gt;render&lt;&#x2F;em&gt; and what they &lt;em&gt;yield&lt;&#x2F;em&gt;âand they always give you the same rendered &lt;abbr&gt;HTML&lt;&#x2F;abbr&gt; and the same yielded values for the same inputs. They&#x27;re just functions!&lt;&#x2F;p&gt;
&lt;h3 id=&quot;x-modal-section&quot;&gt;&lt;code&gt;x-modal-section&lt;&#x2F;code&gt;&lt;&#x2F;h3&gt;
&lt;p&gt;The &lt;code&gt;x-modal-section&lt;&#x2F;code&gt; component is the simplest of all of these: it has no behavior, just some styling to actually chunk up the content:&lt;&#x2F;p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;div class=&#x27;modal-section&#x27;&amp;gt;
  {{yield}}
&amp;lt;&#x2F;div&amp;gt;
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h3 id=&quot;application-controller-and-template&quot;&gt;Application controller and template&lt;&#x2F;h3&gt;
&lt;p&gt;Now, letâs use in the context of the application template, where we can see how the pieces all fit together. First, let&#x27;s see the application controller backing itânothing unusual here, just a simple toggle to show or hide the modal.&lt;sup class=&quot;footnote-reference&quot;&gt;&lt;a href=&quot;#2&quot;&gt;2&lt;&#x2F;a&gt;&lt;&#x2F;sup&gt;&lt;&#x2F;p&gt;
&lt;pre&gt;&lt;code&gt;import Controller from &amp;quot;@ember&#x2F;controller&amp;quot;;
import { action } from &amp;quot;@ember-decorators&#x2F;object&amp;quot;;

export default class Application extends Controller {
  constructor() {
    super(...arguments);
    this.showModal = false;
  }

  @action
  showIt() {
    this.set(&amp;quot;showModal&amp;quot;, true);
  }

  @action
  hideIt() {
    this.set(&amp;quot;showModal&amp;quot;, false);
  }
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Now for the interesting bitâthe template where we invoke &lt;code&gt;x-modal&lt;&#x2F;code&gt; and use its higher-order-component functionality:&lt;&#x2F;p&gt;
&lt;pre&gt;&lt;code&gt;{{#if showModal}}
  {{#x-modal
      button=(component &#x27;x-button&#x27;
        label=&#x27;Close modal!&#x27;
        onClick=(action &#x27;hideIt&#x27;)
      )
      as |modal|
  }}
    {{#modal.section}}
      Here is some content!
    {{&#x2F;modal.section}}

    {{#modal.section}}
      Here is some other content.
    {{&#x2F;modal.section}}

    {{#modal.section}}
      &amp;lt;p&amp;gt;The content can have its own sections, as you&#x27;d expect!&amp;lt;&#x2F;p&amp;gt;
      &amp;lt;p&amp;gt;Nothing crazy going on here. Just a normal template!&amp;lt;&#x2F;p&amp;gt;
    {{&#x2F;modal.section}}
  {{&#x2F;x-modal}}
{{&#x2F;if}}

&amp;lt;button class=&#x27;button&#x27; {{action &#x27;showIt&#x27;}}&amp;gt;Show modal&amp;lt;&#x2F;button&amp;gt;

&amp;lt;!-- some other content on the page --&amp;gt;
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;We invoke the block form of &lt;code&gt;x-modal&lt;&#x2F;code&gt; just like we would any block component, and we get back the thing it yields with &lt;code&gt;as |modal|&lt;&#x2F;code&gt;. However, one of the arguments we pass to it is a component. But &lt;code&gt;modal&lt;&#x2F;code&gt; is a &lt;code&gt;hash&lt;&#x2F;code&gt; (an object!) with a property named &lt;code&gt;section&lt;&#x2F;code&gt;, which is the &lt;code&gt;x-modal-section&lt;&#x2F;code&gt; component.&lt;&#x2F;p&gt;
&lt;p&gt;Again, you can think of this like calling a function with one function as an argument and getting another function back as its return valueâthat returned function being something we could call over and over again once we had it.&lt;&#x2F;p&gt;
&lt;p&gt;Here, we &amp;quot;call the function&amp;quot;âinvoke the &lt;code&gt;x-modal&lt;&#x2F;code&gt; componentâwith &lt;code&gt;component &#x27;x-button&#x27;&lt;&#x2F;code&gt; as its argument, and the returned &lt;code&gt;modal.section&lt;&#x2F;code&gt; is a component we can invoke like a normal component.&lt;sup class=&quot;footnote-reference&quot;&gt;&lt;a href=&quot;#3&quot;&gt;3&lt;&#x2F;a&gt;&lt;&#x2F;sup&gt; We could even pass it into some &lt;em&gt;other&lt;&#x2F;em&gt; component itself if we so desired.&lt;&#x2F;p&gt;
&lt;p&gt;And that&#x27;s really all there is to it!&lt;&#x2F;p&gt;
&lt;h2 id=&quot;summary&quot;&gt;Summary&lt;&#x2F;h2&gt;
&lt;p&gt;&amp;quot;Higher-order components&amp;quot; aren&#x27;t necessarily something you need all the time, but they&#x27;re really convenient and very powerful when you &lt;em&gt;do&lt;&#x2F;em&gt; need them. They&#x27;re also a lot less complicated than the name might seem! Components are just things you can pass around in the context of a component templateâthey&#x27;re the &lt;em&gt;functions&lt;&#x2F;em&gt; of Handlebars.&lt;sup class=&quot;footnote-reference&quot;&gt;&lt;a href=&quot;#4&quot;&gt;4&lt;&#x2F;a&gt;&lt;&#x2F;sup&gt;&lt;&#x2F;p&gt;
&lt;p&gt;Splitting things into components like this does increase complexity, and in particular it can increase the mental overhead of keeping track of how the pieces fit together. However, they also let us cleanly separate different pieces of functionality from each other. Doing it this way means that our modal can be concerned about &lt;em&gt;positioning&lt;&#x2F;em&gt; a button without needing to expose an &lt;abbr&gt;API&lt;&#x2F;abbr&gt; for all of the button&#x27;s own mechanics for handling clicks and performing whatever actions necessary. That makes our modal &lt;em&gt;and&lt;&#x2F;em&gt; our button way more reusable across our application. The button can be used &lt;em&gt;wherever&lt;&#x2F;em&gt; a button is useful, and the modal doesn&#x27;t need to know or care anything about it. Likewise, the button has no need to know anything about the context where it&#x27;s being used; from the button component&#x27;s perspective, it just gets wired up to some actions as usual. The same thing goes for the modal sections: they let us abstract over how the DOM is laid out, what classes are applied to it, and so onâthey chunk up the modal, but the modal itself maintains responsibility for how that chunking up happens. And the caller doesn&#x27;t even &lt;em&gt;have&lt;&#x2F;em&gt; to use that; it&#x27;s just a tool that&#x27;s available for that purpose.&lt;&#x2F;p&gt;
&lt;p&gt;To sum it all up, I&#x27;ll just reiterate my earlier description: components are just like pure functions: the same inputs give you the same outputsâand, just like functions, those inputs and outputs can be other functions, that is, other components.&lt;&#x2F;p&gt;
&lt;div class=&quot;footnote-definition&quot; id=&quot;1&quot;&gt;&lt;sup class=&quot;footnote-definition-label&quot;&gt;1&lt;&#x2F;sup&gt;
&lt;p&gt;If you want a good way to document the things a component &lt;code&gt;yield&lt;&#x2F;code&gt;s, check out &lt;a href=&quot;https:&#x2F;&#x2F;ember-learn.github.io&#x2F;ember-cli-addon-docs&#x2F;latest&#x2F;docs&#x2F;api&#x2F;components&#x2F;docs-demo&quot;&gt;ember-cli-addon-docs&lt;&#x2F;a&gt;, which can read an &lt;code&gt;@yield&lt;&#x2F;code&gt; JSDoc annotation.&lt;&#x2F;p&gt;
&lt;&#x2F;div&gt;
&lt;div class=&quot;footnote-definition&quot; id=&quot;2&quot;&gt;&lt;sup class=&quot;footnote-definition-label&quot;&gt;2&lt;&#x2F;sup&gt;
&lt;p&gt;And it could just as well be a component; the top-level controller template is just where we put our main app functionality.&lt;&#x2F;p&gt;
&lt;&#x2F;div&gt;
&lt;div class=&quot;footnote-definition&quot; id=&quot;3&quot;&gt;&lt;sup class=&quot;footnote-definition-label&quot;&gt;3&lt;&#x2F;sup&gt;
&lt;p&gt;We could also simplify this since we&#x27;re only returning one component, and if we had the full Glimmer component story, this could look &lt;em&gt;very&lt;&#x2F;em&gt; nice:&lt;&#x2F;p&gt;
&lt;&#x2F;div&gt;
&lt;pre&gt;&lt;code&gt;&#96;&#96;&#96;hbs
&amp;lt;Modal @button={{component &#x27;Button&#x27;}} as |Section|&amp;gt;
  &amp;lt;Section&amp;gt;
    Some content!
  &amp;lt;&#x2F;Section&amp;gt;
  &amp;lt;Section&amp;gt;
    Some more content!
  &amp;lt;&#x2F;Section&amp;gt;

  &amp;lt;Section&amp;gt;
    &amp;lt;p&amp;gt;The content can have its own sections, as you&#x27;d expect!&amp;lt;&#x2F;p&amp;gt;
    &amp;lt;p&amp;gt;Nothing crazy going on here. Just a normal template!&amp;lt;&#x2F;p&amp;gt;
  &amp;lt;&#x2F;Section&amp;gt;
&amp;lt;&#x2F;Modal&amp;gt;
&#96;&#96;&#96;
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;div class=&quot;footnote-definition&quot; id=&quot;4&quot;&gt;&lt;sup class=&quot;footnote-definition-label&quot;&gt;4&lt;&#x2F;sup&gt;
&lt;p&gt;If you&#x27;re inclined to &amp;quot;well actually&amp;quot; me about &lt;em&gt;helpers&lt;&#x2F;em&gt; being the real functions of Handlebars templates: in the Glimmer &lt;abbr&gt;VM&lt;&#x2F;abbr&gt; world, helpers are just a kind of component.&lt;&#x2F;p&gt;
&lt;&#x2F;div&gt;
</description>
            </item>
        
    </channel>
</rss>
